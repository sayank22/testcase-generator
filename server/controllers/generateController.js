// backend/src/controllers/generateController.js
import { parseAIResponse } from '../utils/helpers.js';
import AIService from '../services/aiService.js';

/**
 * Get recommended test framework for a given language
 */
function getRecommendedFramework(language) {
  const frameworks = {
    'JavaScript': 'Jest + React Testing Library',
    'TypeScript': 'Jest + React Testing Library',
    'Python': 'pytest',
    'Java': 'JUnit 5',
    'C#': 'xUnit',
    'Go': 'Go testing package',
    'PHP': 'PHPUnit',
    'Ruby': 'RSpec'
  };
  return frameworks[language] || 'Jest';
}

/**
 * Get test file extension for a given language
 */
function getTestFileExtension(language) {
  const extensions = {
    'JavaScript': 'js',
    'TypeScript': 'ts',
    'Python': 'py',
    'Java': 'java',
    'C#': 'cs',
    'Go': 'go',
    'PHP': 'php',
    'Ruby': 'rb'
  };
  return extensions[language] || 'js';
}

/**
 * Simple fallback test code template if AI fails
 */
function generateTestTemplate(summary, files, language) {
  const templates = {
    'JavaScript': `// ${summary.title}
// Generated by Test Case Generator

describe('${summary.title}', () => {
  beforeEach(() => {});
  afterEach(() => {});

  test('renders correctly', () => expect(true).toBe(true));
  test('handles props', () => expect(true).toBe(true));
  test('handles interactions', () => expect(true).toBe(true));
});`,

    'Python': `# ${summary.title}
# Generated by Test Case Generator

import unittest

class Test${summary.title.replace(/\s+/g, '')}(unittest.TestCase):
    def setUp(self):
        pass

    def tearDown(self):
        pass

    def test_basic(self):
        self.assertTrue(True)

if __name__ == '__main__':
    unittest.main()`
  };

  return templates[language] || templates['JavaScript'];
}

/**
 * Generate test summaries from repository files
 */
export const generateSummaries = async (req, res) => {
  try {
    const { files, repository } = req.body;

    if (!files?.length) {
      return res.status(400).json({ error: 'Files array is required' });
    }
    if (!repository?.full_name) {
      return res.status(400).json({ error: 'Repository information is required' });
    }

    const fileContents = [];
    const [owner, repoName] = repository.full_name.split('/');

    // Limit to first 10 files to avoid excessive tokens
    for (const file of files.slice(0, 10)) {
      try {
        const { data: fileData } = await req.client.octokit.rest.repos.getContent({
          owner,
          repo: repoName,
          path: file.path
        });

        if (fileData.type === 'file' && fileData.content) {
          const content = Buffer.from(fileData.content, 'base64').toString('utf-8');
          fileContents.push({
            path: file.path,
            content: content.substring(0, 3000), // limit content length
            language: file.language,
            size: content.length
          });
        }
      } catch (err) {
        console.error(`❌ Error fetching ${file.path}:`, err.message);
      }
    }

    if (!fileContents.length) {
      return res.status(400).json({ error: 'No valid file contents retrieved' });
    }

    let testSummaries;
    try {
      const aiResponse = await AIService.generateTestSummaries(fileContents, repository.language);
      testSummaries = Array.isArray(aiResponse)
        ? aiResponse
        : parseAIResponse(aiResponse, fileContents);
    } catch (err) {
      console.warn('⚠️ AI failed to generate summaries:', err.message);
      return res.status(500).json({ error: 'Failed to generate test summaries from AI' });
    }

    testSummaries = testSummaries.map((summary, index) => ({
      id: summary.id || index + 1,
      title: summary.title || 'Generated Test Suite',
      description: summary.description || '',
      framework: summary.framework || getRecommendedFramework(repository.language),
      testCount: summary.testCount || Math.max(fileContents.length * 3, 5),
      files: summary.files || fileContents.map(f => f.path.split('/').pop()),
      category: summary.category || 'unit',
      language: repository.language
    }));

    res.json(testSummaries);
  } catch (error) {
    console.error('❌ generateSummaries error:', error);
    res.status(500).json({ error: 'Failed to generate test summaries' });
  }
};

/**
 * Generate runnable test code from a summary
 */
export const generateCode = async (req, res) => {
  try {
    const { summary, files, repository } = req.body;

    if (!summary?.title) {
      return res.status(400).json({ error: 'Test summary is required' });
    }
    if (!Array.isArray(files)) {
      return res.status(400).json({ error: 'Files array is required' });
    }

    let testCode;
    try {
      testCode = await AIService.generateTestCode(summary, files, repository.language);
    } catch (err) {
      console.warn('⚠️ AI failed, using fallback template:', err.message);
      testCode = generateTestTemplate(summary, files, repository.language);
    }

    const filename = `${summary.title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')}.test.${getTestFileExtension(repository.language)}`;

    res.json({
      code: testCode,
      filename,
      framework: summary.framework || getRecommendedFramework(repository.language),
      language: repository.language
    });
  } catch (error) {
    console.error('❌ generateCode error:', error);
    res.status(500).json({ error: 'Failed to generate test code' });
  }
};
